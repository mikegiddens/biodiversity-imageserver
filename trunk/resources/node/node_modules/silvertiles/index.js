
var	path = require('path');
var _ = require('underscore');
var sprintf = require('sprintf').sprintf;
var fs = require('fs');
var mkdirp = require('mkdirp');
var	gm = require('gm');


var SilverTiles = function(params){
	params = ('undefined' != typeof params) ? params : '';
	var record = {};
	var tileSize = ('undefined' != typeof params.tileSize && params.tileSize !='') ? params.tileSize : 256;
	var sourcePath = ('undefined' != typeof params.sourcePath && params.sourcePath !='') ? params.sourcePath : '';
	var image = ('undefined' != typeof params.image && params.image !='') ? params.image : '';
	var sharpenFlag = ('undefined' != typeof params.sharpenFlag && params.sharpenFlag == 'true') ? true : false;
	var zoomLevel;
	
	var cachePath = 'G:\\wamp\\www\\bis\\resources\\node\\cacheFolder\\';
	var baseUrl = '';
	
	function generateTiles() {
		console.log(tileSize);
	}

	function getOriginalDimensions() {
		if(this.sourceExist()) {
			gm( path.normalize(sourcePath + image) ).size(function(err, value){
				if('undefined' != typeof value) {
					return {width : value.width, height : value.height};
				} else {
					return false;
				}
			});
		} else {
			return false;
		}
	}

	function sourceExist() {
		return(path.existsSync( path.normalize(sourcePath + image)));
	}

	function cacheExist() {
		return(path.existsSync(this.getTileLocation()));
	}

	// function touchCache() {
		// $this->getTileLevels();
		// @touch($this->getTileLocation());
	// }
	
	function set(field,value) {
		if (field != '' && 'undefined' != typeof field && 'undefined' != typeof value ) {
			record[field] = value;
			return(true);
		} else {
			return(false);
		}
	}

	function get(field) {
		return (field != '' && 'undefined' != typeof field) ? record[field] : false;
	}
	
	function getTileLocation() {
		mkdirp.sync(cachePath);
		return(cachePath + path.basename(image,'.jpg').toLowerCase() + '\\');
	}

	function createTileLocation() {
		mkdirp.sync(this.getTileLocation(), 0775);
		return true;
	}

	function getZoomLevel() {
		return this.get('zoomLevel');
	}
	
	function getTileLevels() {
		var dimensions = this.getOriginalDimensions();
		var i = 1;
		while(dimensions.height > (Math.pow(i,4) * tileSize)) {
			i++;
		}
		if(i<=1) i=4;
		i++; 
		zoomLevel = i;
		return(i);
	}

	function getUrl() {
		return(baseUrl + 'cacheFolder/' + path.basename(image,'.jpg').toLowerCase() + '/');
	}

	function getTempFileLocation() {
		return(this.getTileLocation() + 'tmpFile.jpg');
	}

	function tempFileExist() {
		return(path.existsSync( path.normalize(this.getTempFileLocation())));
	}

	function createTiles() {
		this.createTileLocation();
		var timeStart = Date.now();
		var time,x,width,height,tmpCachePath,source;
		var originalDimensions = this.getOriginalDimensions();

		for(var j= this.getTileLevels(); j>=1; j--) {
			time = Date.now() - timeStart;
			x = Math.pow(j,2);
			width = height = tileSize * x;
			tmpCachePath = this.getTileLocation() + j + '\\';
			if(!path.existsSync(tmpCachePath)) mkdirp.sync((tmpCachePath, 0775));

			if(this.tempFileExist()) {
				source = this.getTempFileLocation();
				gm(source).resize(Math.round(originalDimensions.width/2), Math.round(originalDimensions.height/2));
			} else {
				source = sourcePath + image;
				this.copyFileSync(source, this.getTempFileLocation());
				source = this.getTempFileLocation();
			}

			if(j == 1) {
				// $tmp = sprintf("convert %s -background transparent -gravity center -resize %sx%s -extent %sx%s %s  %s%s_%s.jpg"
					// ,	$source
					// ,	$width
					// ,	$height
					// ,	$width
					// ,	$height
					// ,	$sharpen
					// ,	$tmpCachePath
					// ,	"tile"
					// ,	0
				// );

				// $res = system($tmp);
				gm(source).resize(width,height);
				fs.renameSync(source, tmpCachePath + 'tile_0.jpg');
			} else {
				// $tmp = sprintf("convert %s -background transparent -gravity center -resize %sx%s -extent %sx%s %s   -crop %sx%s  %s%s_%%d.jpg"
					// ,	$source
					// ,	$width
					// ,	$height
					// ,	$width
					// ,	$height
					// ,	$sharpen
					// ,	$this->get("tileSize")
					// ,	$this->get("tileSize")
					// ,	$tmpCachePath
					// ,	"tile"
					// ,	$i
				// );
				// $res = system($tmp);
				
				
			}
			// $tmp = sprintf("rm %s", $this->getTempFileLocation());
			// $res = system($tmp);
		}
		time = Date.now() - timeStart;
	}


	// function findOldestFile($directory) {
		// $directory = rtrim($directory,'/') . '/';
		// if ($handle = opendir($directory)) {
			// while (false !== ($file = readdir($handle))) {
				// if($file != "." && $file != "..") {
					// $file_date[$file] = filemtime($directory . $file);
				// }
			// }
		// }
		// closedir($handle);
		// if(is_array($file_date) && count($file_date)) {
		// asort($file_date, SORT_NUMERIC);
		// reset($file_date);
		// $oldest = key($file_date);
		// return $oldest;
		// }
		// return false;
	// }
	
	function copyFileSync(srcFile, destFile) {
/* CREDITS
 * http://procbits.com/2011/11/15/synchronous-file-copy-in-node-js/
 */
		var BUF_LENGTH, buff, bytesRead, fdr, fdw, pos;
		BUF_LENGTH = 64 * 1024;
		buff = new Buffer(BUF_LENGTH);
		fdr = fs.openSync(srcFile, 'r');
		fdw = fs.openSync(destFile, 'w');
		bytesRead = 1;
		pos = 0;
		while (bytesRead > 0) {
			bytesRead = fs.readSync(fdr, buff, 0, BUF_LENGTH, pos);
			fs.writeSync(fdw, buff, 0, bytesRead);
			pos += bytesRead;
		}
		fs.closeSync(fdr);
		return fs.closeSync(fdw);
	}

	function barcodePath( barcode ) {
		var id = barcode,loop_flag = true,i = 0,prefix = '',destPath = '';
						
		if (id.length > 8){
			while(loop_flag){
				if(barcode.substr(i) * 1) {
					loop_flag = false;
				} else {
					i++;
				}
				if (i>8) loop_flag = false;
			}
			prefix = id.substr(0,i);
			if (id.substr(i, 1) == "-") {
				prefix += "-";
			}
			id = Math.abs(id.substr(i));
		} else {		
			prefix = "";
		}
		destPath = prefix + "/";
		destPath += parseInt(Math.abs(id / 1000000) + '') + "/";
		destPath += parseInt(Math.abs( (id % 1000000) / 10000) + '') + "/";
		destPath += parseInt(Math.abs( (id % 10000) / 100) + '') + "/";
		destPath += parseInt(Math.abs( (id % 100)) + '') + "/";
		return( destPath );
	}


	
	return {
		generateTiles : generateTiles,
		sourceExist : sourceExist,
		getOriginalDimensions : getOriginalDimensions,
		getTileLocation : getTileLocation,
		createTileLocation : createTileLocation,
		getZoomLevel : getZoomLevel,
		get : get,
		set : set,
		sourceExist : sourceExist,
		
		copyFileSync : copyFileSync,
		barcodePath : barcodePath
	};

}

module.exports = SilverTiles;